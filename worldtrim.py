# Minecraft World Trimmer 1.0
#
# Requirements: pymclevel (mcedit), numpy, scipy

import sys
import os
import signal
import json
import numpy
import scipy.misc
import pymclevel
import optparse
import traceback
import datetime
import itertools


USAGE ="""Usage: %prog [options] <command> [<world folder>]

Commands:
  extract - extract information from regions in <world folder>
  trim    - remove regions from <world folder>
  show    - print information and generate map for deleted regions
  clean   - remove all files generated by %prog"""
JSON = 'world.json'
IMG = 'world.png'


class Application(object):

    def run(self, command, world_folder=None, border=None, spawn=None,
            inhabited=None, old=None):
        self.stop = False
        self.border = border
        self.spawn = spawn
        self.inhabited = inhabited
        self.old = old
    
        signal.signal(signal.SIGINT, self.signal_handler)

        if len(args) < 1:
            raise Exception("Command missing.")
        if not args[0] in ['extract', 'show', 'trim', 'clean']:
            raise Exception("Unknown command.")
        if command in ['extract', 'trim']:
            if world_folder is None:
                raise Exception("World folder missing.")
        region_data = None
        if os.path.exists(JSON):
            with open(JSON) as f:
                region_data = json.load(f)
        if command in ['show', 'trim'] and region_data is None:
            raise Exception("Please run extract first.")

        if command == 'clean':
            self.clean()
        elif command == 'extract':
            self.extract(world_folder, region_data)
        elif command == 'trim':
            self.trim(world_folder, region_data)
        elif command == 'show':
            self.show(region_data)

    def iter_regions(self, folder, skip=0):
        regionDir = folder.getFolderPath("region")
        regionFiles = os.listdir(regionDir)
        regionFiles.sort()
        for filename in regionFiles[skip:]:
            region = folder.tryLoadRegionFile(os.path.join(regionDir, filename))
            if not region is None and region.offsets.any():
                yield region
    
    def iter_chunks(self, region):
        rx, rz = region.regionCoords
        for index, offset in enumerate(region.offsets):
            if offset:
                yield (index % 32 + rx * 32, index / 32 + rz * 32)
    
    def extract(self, world_path, region_data):
        level = pymclevel.fromFile(os.path.join(world_path, "level.dat"))
        if region_data is None:
            region_data = []
        folder = pymclevel.infiniteworld.AnvilWorldFolder(world_path)
        num_regions = sum(1 for i in self.iter_regions(folder))
        skip = len(region_data)
        if skip:
            sys.stdout.write('{0:,} / {1:,} regions already processed. Run clean first to start over.\n'.format(skip, num_regions))
            if skip == num_regions:
                return
        for region in self.iter_regions(folder, skip):
            if self.stop:
                break
            rx, rz = region.regionCoords
            max_inhabited = 0
            for cx, cz in self.iter_chunks(region):
                if not level.containsChunk(cx, cz):
                    continue
                level_data = level.getChunk(cx, cz).root_tag['Level']
                max_inhabited = max(level_data['InhabitedTime'].value, max_inhabited)
            region_data.append((rx, rz, max_inhabited))
            if len(region_data) % 10 == 0:
                sys.stdout.write('{0:,} / {1:,} regions processed\n'.format(len(region_data), num_regions))
        
        with open(JSON, 'w') as f:
            json.dump(region_data, f)
        
    def analyze(self, region_data):
        outside = set()
        uninhabited = set()
        connected = set()
        inhabited = set()
        spawn = set()

        # mark uninhabited regions, spawn regions, and regions outside of the border
        for rx, rz, max_inhabited in region_data:
            if max(abs(rx), abs(rz)) > self.border:
                outside.add((rx, rz))
            elif max(abs(rx), abs(rz)) < self.spawn:
                spawn.add((rx, rz))
            elif max_inhabited >= self.inhabited:
                inhabited.add((rx, rz))
            else:
                uninhabited.add((rx, rz))
        
        # unmark regions whose neighbors are kept
        for rx, rz in uninhabited:
            for nx, nz in [(rx + 1, rz), (rx - 1, rz), (rx, rz + 1), (rx, rz - 1)]:
                if (nx, nz) in inhabited:
                    connected.add((rx, rz))
                    break
        uninhabited = [region for region in uninhabited if not region in connected]
        return spawn, inhabited, connected, uninhabited, outside
    
    def show(self, region_data):
        spawn, inhabited, connected, uninhabited, outside = self.analyze(region_data)
    
        # print info
        sys.stdout.write('total regions:       {0}\n'.format(len(region_data)))
        sys.stdout.write('spawn regions:       {0}\n'.format(len(spawn)))
        sys.stdout.write('inhabited regions:   {0}\n'.format(len(inhabited)))
        sys.stdout.write("connected regions:   {0}\n".format(len(connected)))
        sys.stdout.write("uninhabited regions: {0}\n".format(len(uninhabited)))
        sys.stdout.write('outside the border:  {0}\n'.format(len(outside)))
        sys.stdout.write("deletable regions:   {0}\n".format(len(uninhabited) + len(outside)))
    
        # generate image
        img = numpy.zeros((self.border * 2 + 1, self.border * 2 + 1, 4), 'uint8')
        for rx, rz in spawn:
            img[rz + self.border][rx + self.border] = [255, 255, 255, 255]
        for rx, rz in inhabited:
            img[rz + self.border][rx + self.border] = [0, 255, 0, 255]
        for rx, rz in connected:
            img[rz + self.border][rx + self.border] = [255, 255, 0, 255]
        for rx, rz in uninhabited:
            img[rz + self.border][rx + self.border] = [255, 0, 0, 255]
    
        # save image
        scipy.misc.imsave(IMG, img)
        sys.stdout.write("Saved map as {0}.\n".format(IMG))
    
    def trim(self, world_folder, region_data):
        _, _, _, uninhabited, outside = self.analyze(region_data)
        sys.stdout.write("deletable regions: {0}\n".format(len(uninhabited)))
        count = 0
        for rx, rz in itertools.chain(uninhabited, outside):
            path = os.path.join(world_folder, 'region', 'r.{0}.{1}.mca'.format(rx, rz))
            if not os.path.isabs(path):
                path = os.path.join(os.getcwd(), path)
            if os.path.exists(path):
                last_update = datetime.datetime.fromtimestamp(os.path.getmtime(path))
                now = datetime.datetime.now()
                if last_update < now - datetime.timedelta(days=self.old):
                    os.remove(path)
                    count += 1
        sys.stdout.write("deleted regions:   {0}\n".format(count))
    
    def clean(self):
        if os.path.exists(JSON):
            os.remove(JSON)
        if os.path.exists(IMG):
            os.remove(IMG)
    
    def signal_handler(self, signal, frame):
        sys.stdout.write("Aborting...\n")
        self.stop = True
   
   
if __name__ == '__main__':
    parser = optparse.OptionParser(usage=USAGE)
    parser.add_option("-b", "--border", action='store', type='int', default=6000,
                      dest='border', help="distance from 0,0 in regions (512m) beyond which all regions are deleted")
    parser.add_option("-s", "--spawn", action='store', type='int', default=16,
                      dest='spawn', help="distance from 0,0 in regions (512m) within which all regions are kept")
    parser.add_option("-i", "--inhabited", action='store', type='int', default=18000,
                      dest='inhabited', help="number of ticks before a chunk is considered inhabited")
    parser.add_option("-o", "--old", action='store', type='int', default=60,
                      dest='old', help="number of days before a region is considered old")
    options, args = parser.parse_args()

    try:
        Application().run(*args, **vars(options))
    except Exception as e:
        sys.stderr.write("Error: {0} See -h for details.\n".format(e))
        exit(1)
